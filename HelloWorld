public static class JsonHelper
{
    public static async Task<JsonDocument> KeepOnlyKeysAsync(JsonDocument inputJson, List<string> keysToKeep)
    {
        using (var stream = new MemoryStream())
        using (var writer = new Utf8JsonWriter(stream))
        {
            if (inputJson.RootElement.ValueKind == JsonValueKind.Object)
            {
                writer.WriteStartObject();
                KeepOnlyKeysRecursive(inputJson.RootElement, writer, keysToKeep);
                writer.WriteEndObject();
            }
            else if (inputJson.RootElement.ValueKind == JsonValueKind.Array)
            {
                writer.WriteStartArray();
                foreach (var element in inputJson.RootElement.EnumerateArray())
                {
                    writer.WriteStartObject();
                    KeepOnlyKeysRecursive(element, writer, keysToKeep);
                    writer.WriteEndObject();
                }
                writer.WriteEndArray();
            }
            await writer.FlushAsync();
            stream.Position = 0;
            return await JsonDocument.ParseAsync(stream);
        }
    }

    private static void KeepOnlyKeysRecursive(JsonElement element, Utf8JsonWriter writer, List<string> keysToKeep)
    {
        foreach (var property in element.EnumerateObject())
        {
            if (keysToKeep.Contains(property.Name))
            {
                property.WriteTo(writer);
            }
            else if (property.Value.ValueKind == JsonValueKind.Object)
            {
                writer.WriteStartObject(property.Name);
                KeepOnlyKeysRecursive(property.Value, writer, keysToKeep);
                writer.WriteEndObject();
            }
            else if (property.Value.ValueKind == JsonValueKind.Array)
            {
                writer.WriteStartArray(property.Name);
                foreach (var item in property.Value.EnumerateArray())
                {
                    if (item.ValueKind == JsonValueKind.Object)
                    {
                        writer.WriteStartObject();
                        KeepOnlyKeysRecursive(item, writer, keysToKeep);
                        writer.WriteEndObject();
                    }
                    else
                    {
                        item.WriteTo(writer);
                    }
                }
                writer.WriteEndArray();
            }
        }
    }

    public static async Task WriteJsonAsync(string folderPath, string fileName, JsonDocument jsonDocument)
    {
        var dynamicObject = ConvertJsonDocumentToDynamic(jsonDocument);
        await WriteJsonAsync(folderPath, fileName, dynamicObject);
    }

    public static async Task WriteJsonAsync(string folderPath, string fileName, string jsonFilePath)
    {
        var jsonString = await File.ReadAllTextAsync(jsonFilePath);
        var dynamicObject = JsonSerializer.Deserialize<dynamic>(jsonString);
        await WriteJsonAsync(folderPath, fileName, dynamicObject);
    }

    private static async Task WriteJsonAsync(string folderPath, string fileName, dynamic obj)
    {
        var options = new JsonSerializerOptions { WriteIndented = true };
        var jsonString = JsonSerializer.Serialize(obj, options);
        await FileOperationsHelper.WriteFileAsync(folderPath, fileName, jsonString, "json");
    }

    private static dynamic ConvertJsonDocumentToDynamic(JsonDocument jsonDocument)
    {
        var jsonString = jsonDocument.RootElement.GetRawText();
        return JsonSerializer.Deserialize<dynamic>(jsonString);
    }
}

public static class FileOperationsHelper
{
    public static async Task WriteFileAsync(string folderPath, string fileName, string content, string extension)
    {
        if (!Directory.Exists(folderPath))
        {
            Directory.CreateDirectory(folderPath);
        }

        var filePath = Path.Combine(folderPath, $"{fileName}.{extension}");
        await File.WriteAllTextAsync(filePath, content);
    }
}
